import uuid
import random
import os
import json
import time
from datetime import datetime
from typing import Dict, Any, List
import threading
import smtplib
from email.message import EmailMessage
import os as _os
try:
    import db
except Exception:
    db = None

# Load QA pairs for simple auto-responses (optional). Expect QA.json at repo root.
QA_PAIRS: List[Dict[str, str]] = []
try:
    qa_path = os.path.join(os.path.dirname(__file__), 'QA.json')
    if os.path.exists(qa_path):
        with open(qa_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            if isinstance(data, dict):
                for k, v in data.items():
                    QA_PAIRS.append({'q': str(k), 'a': str(v)})
            elif isinstance(data, list):
                for item in data:
                    if isinstance(item, dict):
                        if 'q' in item and 'a' in item:
                            QA_PAIRS.append({'q': str(item['q']), 'a': str(item['a'])})
                        else:
                            for k, v in item.items():
                                QA_PAIRS.append({'q': str(k), 'a': str(v)})
except Exception:
    QA_PAIRS = []


def _send_contact_notification(player: Dict[str, Any], room_id: str, reason: str = 'takeover'):
    """Send a simple notification to player's contact_email if configured.
    Looks for SMTP env vars: SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS, EMAIL_FROM.
    If not configured, write an entry to 'notifications.log' as a fallback.
    reason: 'takeover' or 'released'
    """
    try:
        contact_email = player.get('contact_email')
        contact_phone = player.get('contact_phone')
        name = player.get('name') or player.get('display_name') or 'Player'
        if contact_email:
            host = _os.environ.get('SMTP_HOST')
            port = int(_os.environ.get('SMTP_PORT', '25'))
            user = _os.environ.get('SMTP_USER')
            pwd = _os.environ.get('SMTP_PASS')
            frm = _os.environ.get('EMAIL_FROM') or (user or 'no-reply@example.com')
            subject = ''
            body = ''
            if reason == 'takeover':
                subject = f'ゲーム代行開始のお知らせ — ルーム {room_id}'
                body = f'{name} 様\n\n大富豪のプレイ中に接続が途切れたため、代行ボットがあなたの代わりにプレイしています。\nルームID: {room_id}\n\n再接続すると自動的に操作権が戻ります。'
            else:
                subject = f'ゲーム操作の復帰のお知らせ — ルーム {room_id}'
                body = f'{name} 様\n\n接続が復帰したため、ゲーム操作をあなたに戻しました。\nルームID: {room_id}\n\n引き続きゲームをお楽しみください。'
            if host and user and pwd:
                msg = EmailMessage()
                msg['Subject'] = subject
                msg['From'] = frm
                msg['To'] = contact_email
                msg.set_content(body)
                try:
                    with smtplib.SMTP(host, port, timeout=10) as s:
                        s.starttls()
                        s.login(user, pwd)
                        s.send_message(msg)
                except Exception:
                    with open('notifications.log', 'a', encoding='utf-8') as f:
                        f.write(f"{datetime.utcnow().isoformat()} EMAIL_FAIL to:{contact_email} subj:{subject}\n")
            else:
                with open('notifications.log', 'a', encoding='utf-8') as f:
                    f.write(f"{datetime.utcnow().isoformat()} NOTIFY to:{contact_email} reason:{reason} room:{room_id}\n")
        elif contact_phone:
            with open('notifications.log', 'a', encoding='utf-8') as f:
                f.write(f"{datetime.utcnow().isoformat()} SMS to:{contact_phone} reason:{reason} room:{room_id}\n")
    except Exception:
        try:
            with open('notifications.log', 'a', encoding='utf-8') as f:
                f.write(f"{datetime.utcnow().isoformat()} NOTIFY_ERR for player:{player.get('id')} room:{room_id}\n")
        except Exception:
            pass

# rank -> title mapping (1-based rank)
TITLE_MAP = {
    1: '大富豪',
    2: '富豪',
    3: '平民',
    4: '貧民',
    5: '大貧民',
}


def title_for_rank(rank: int) -> str:
    return TITLE_MAP.get(rank, f'Rank{rank}')

# In-memory rooms store (not persistent)
ROOMS: Dict[str, Dict[str, Any]] = {}
# per-room event queues for SSE
ROOM_EVENTS: Dict[str, List[Dict[str, Any]]] = {}


def emit_event(room_id: str, event_type: str, payload: Dict[str, Any]):
    """Append an event to the room's event queue. Clients poll via SSE endpoint."""
    ROOM_EVENTS.setdefault(room_id, []).append({'type': event_type, 'payload': payload})


def pop_events(room_id: str):
    return ROOM_EVENTS.pop(room_id, [])


def make_deck() -> List[str]:
    # use exactly these four suits: spade, club, diamond, heart
    suits = ['♠', '♣', '♦', '♥']
    ranks = ['3','4','5','6','7','8','9','10','J','Q','K','A','2']
    cards = [f"{r}{s}" for s in suits for r in ranks]
    # add two jokers (represented as 'JOKER')
    cards.extend(['JOKER', 'JOKER'])
    return cards


def create_room(creator_name: str) -> Dict[str, Any]:
    room_id = uuid.uuid4().hex[:8]
    player_id = uuid.uuid4().hex
    room = {
        'id': room_id,
        'players': [
            {'id': player_id, 'name': creator_name, 'is_bot': False, 'contact_email': None, 'contact_phone': None}
        ],
        'creator': player_id,
        'started': False,
        'current_turn': 0,
        'hands': {},  # player_id -> list of cards
        'center': [],
        'deck': [],
        'messages': [],
        'last_player': None,
        'consecutive_passes': 0,
        'next_rank': 1,
        'direction': 'clockwise',
    }
    ROOMS[room_id] = room
    return {'room': room, 'player_id': player_id}


def add_bot(room_id: str, display_name: str = None, tone: str = 'いじわる', difficulty: str = 'ふつう') -> Dict[str, Any]:
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    if room.get('started'):
        raise RuntimeError('game already started')
    pid = uuid.uuid4().hex
    # choose a simple incremental name if needed
    name = f'Bot{len(room.get("players", []))+1}'
    bot = {'id': pid, 'name': name, 'is_bot': True, 'display_name': display_name or 'イジヒコ', 'tone': tone, 'difficulty': difficulty, 'contact_email': None, 'contact_phone': None}
    room.setdefault('players', []).append(bot)
    return bot


def remove_bot(room_id: str, bot_id: str) -> bool:
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    if room.get('started'):
        raise RuntimeError('game already started')
    before = len(room.get('players', []))
    room['players'] = [p for p in room.get('players', []) if not (p.get('is_bot') and p.get('id') == bot_id)]
    after = len(room.get('players', []))
    return after < before


def join_room(room_id: str, name: str) -> Dict[str, Any]:
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    # create player id and append
    pid = uuid.uuid4().hex
    room['players'].append({'id': pid, 'name': name, 'is_bot': False, 'contact_email': None, 'contact_phone': None})
    return {'room': room, 'player_id': pid}


def start_game(room_id: str) -> Dict[str, Any]:
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    # ensure exactly 5 players: if fewer than 5, auto-fill with bots
    players = room.get('players', [])
    TARGET_PLAYERS = 5
    if len(players) < TARGET_PLAYERS:
        existing_names = set(p.get('name') for p in players)
        next_idx = 1
        # find a starting index that doesn't collide with existing Bot names
        while f'Bot{next_idx}' in existing_names:
            next_idx += 1
        while len(players) < TARGET_PLAYERS:
            pid = uuid.uuid4().hex
            name = f'Bot{next_idx}'
            # add bot customization fields: display_name (editable), tone, difficulty
            players.append({'id': pid, 'name': name, 'is_bot': True, 'display_name': 'イジヒコ', 'tone': 'いじわる', 'difficulty': 'ふつう'})
            existing_names.add(name)
            next_idx += 1
        room['players'] = players
    # create and shuffle deck
    deck = make_deck()
    random.shuffle(deck)
    # deal cards evenly to players
    players = room.get('players', [])
    if not players:
        raise RuntimeError('no players')
    hands = {p['id']: [] for p in players}
    i = 0
    while deck:
        pid = players[i % len(players)]['id']
        hands[pid].append(deck.pop())
        i += 1
    room['hands'] = hands
    room['deck'] = deck
    room['started'] = True
    room['center'] = []
    room['current_turn'] = 0
    room['turn_started_at'] = datetime.utcnow().isoformat() + 'Z'
    room['last_player'] = None
    room['consecutive_passes'] = 0
    room['next_rank'] = 1
    room['revolution'] = False
    room['game_over'] = False
    # emit no events here; caller may check state
    # After dealing, if there are saved finished ranks from previous round, handle auto/pend transfers
    # finished mapping: player_id -> rank (1..N)
    finished = room.get('finished', {})
    if finished:
        # build reverse map rank->player
        rank_to_pid = {r: pid for pid, r in finished.items()}
        # determine roles based on ranks if those ranks exist
        # large mapping: 1: 大富豪, 2: 富豪, 3: 平民, 4: 貧民, 5: 大貧民
        daifugo = rank_to_pid.get(1)
        fugou = rank_to_pid.get(2)
        heimin = rank_to_pid.get(3)
        hinmin = rank_to_pid.get(4)
        daihinmin = rank_to_pid.get(5)

        def strongest_cards(pid, n=1):
            hand = list(room['hands'].get(pid, []))
            # sort by rank index ascending -> weakest first, so pick from end
            sorted_hand = sorted(hand, key=lambda c: _rank_value(c))
            return sorted_hand[-n:][::-1] if sorted_hand else []

        # 大貧民 -> 大富豪: automatically give top 2 to 大富豪
        if daihinmin and daifugo:
            to_transfer = strongest_cards(daihinmin, 2)
            if to_transfer:
                for c in to_transfer:
                    try:
                        room['hands'][daihinmin].remove(c)
                    except ValueError:
                        pass
                room['hands'].setdefault(daifugo, []).extend(to_transfer)
                try:
                    emit_event(room_id, 'auto_transfer', {'from': daihinmin, 'to': daifugo, 'cards': to_transfer})
                except Exception:
                    pass

        # 貧民 -> 富豪: automatically give top 1 to 富豪
        if hinmin and fugou:
            to_transfer = strongest_cards(hinmin, 1)
            if to_transfer:
                for c in to_transfer:
                    try:
                        room['hands'][hinmin].remove(c)
                    except ValueError:
                        pass
                room['hands'].setdefault(fugou, []).extend(to_transfer)
                try:
                    emit_event(room_id, 'auto_transfer', {'from': hinmin, 'to': fugou, 'cards': to_transfer})
                except Exception:
                    pass

        # Now set pending gives for 富豪 (give 1) and 大富豪 (give 2) so they may choose which cards to give back
        if fugou and hinmin:
            room['pending_give'] = room.get('pending_give', {})
            room['pending_give'][fugou] = {'to': hinmin, 'count': 1, 'allowed': True}
        if daifugo and daihinmin:
            room['pending_give'] = room.get('pending_give', {})
            room['pending_give'][daifugo] = {'to': daihinmin, 'count': 2, 'allowed': True}

    return room


def _rank_value(card: str) -> int:
    # card like 'A♠' or '10♣' -> rank value according to 3..2
    if card == 'JOKER':
        # treat joker as highest index
        return 999
    rank = card[:-1]
    order = ['3','4','5','6','7','8','9','10','J','Q','K','A','2']
    try:
        return order.index(rank)
    except ValueError:
        return -1


def _rank_index_from_rank(rank: str) -> int:
    order = ['3','4','5','6','7','8','9','10','J','Q','K','A','2']
    if not rank:
        return -1
    if rank == 'JOKER':
        return 999
    try:
        return order.index(rank)
    except ValueError:
        return -1


def _rank_greater(a_idx: int, b_idx: int, revolution: bool = False) -> bool:
    """Return True if rank index a is considered greater than b under current revolution state.
    Normally higher index wins; under revolution the ordering is inverted.
    """
    if revolution:
        return a_idx < b_idx
    return a_idx > b_idx


def _is_straight(cards: List[str]) -> bool:
    # Require at least length 3 for a straight
    if len(cards) < 3:
        return False
    # Support jokers as wildcards in straights.
    n = len(cards)
    # gather non-joker cards
    nonjoker = [c for c in cards if c != 'JOKER']
    # all non-joker cards must share the same suit
    if nonjoker:
        suits = [c[-1] for c in nonjoker]
        if len(set(suits)) != 1:
            return False
    # compute rank indices for non-jokers
    nonjoker_idxs = sorted([_rank_value(c) for c in nonjoker])
    # no duplicate ranks among non-jokers (same suit so duplicates impossible)
    if len(set(nonjoker_idxs)) != len(nonjoker_idxs):
        return False
    jokers = len([c for c in cards if c == 'JOKER'])
    # try to find a consecutive window of length n that contains all non-joker indices
    max_rank = 12  # index of '2' in our order
    for start in range(0, max_rank - n + 2):
        end = start + n - 1
        ok = True
        for idx in nonjoker_idxs:
            if idx < start or idx > end:
                ok = False
                break
        if ok:
            return True
    return False


def _straight_top_idx(cards: List[str]) -> int:
    """If cards can form a straight (with jokers), return the maximum possible top index.
    Returns -1 if not possible.
    """
    n = len(cards)
    nonjoker = [c for c in cards if c != 'JOKER']
    if not _is_straight(cards):
        return -1
    # if all jokers, choose highest possible straight top
    if not nonjoker:
        return 12
    nonjoker_idxs = sorted([_rank_value(c) for c in nonjoker])
    max_rank = 12
    best_top = -1
    for start in range(0, max_rank - n + 2):
        end = start + n - 1
        ok = True
        for idx in nonjoker_idxs:
            if idx < start or idx > end:
                ok = False
                break
        if ok:
            best_top = max(best_top, end)
    return best_top


def _play_meta(cards: List[str]) -> Dict[str, Any]:
    # Determine whether cards represent a 'set' (same rank) or 'straight'
    if not cards:
        return {'type': 'empty'}
    # handle jokers
    ranks = [ (c[:-1] if c!='JOKER' else 'JOKER') for c in cards]
    suits = [ (c[-1] if c!='JOKER' else 'JOKER') for c in cards]
    all_spades = all(s == '♠' for s in suits)
    contains_8 = any((c[:-1] if c!='JOKER' else '') == '8' for c in cards)
    contains_5 = any((c[:-1] if c!='JOKER' else '') == '5' for c in cards)
    contains_7 = any((c[:-1] if c!='JOKER' else '') == '7' for c in cards)
    contains_9 = any((c[:-1] if c!='JOKER' else '') == '9' for c in cards)
    contains_10 = any((c[:-1] if c!='JOKER' else '') == '10' for c in cards)
    contains_K = any((c[:-1] if c!='JOKER' else '') == 'K' for c in cards)
    contains_4 = any((c[:-1] if c!='JOKER' else '') == '4' for c in cards)
    contains_A = any((c[:-1] if c!='JOKER' else '') == 'A' for c in cards)
    contains_Q = any((c[:-1] if c!='JOKER' else '') == 'Q' for c in cards)
    contains_J = any((c[:-1] if c!='JOKER' else '') == 'J' for c in cards)
    contains_joker = any(c == 'JOKER' for c in cards)

    # set: all ranks equal OR jokers can act as wildcards to complete a set
    # determine base ranks excluding jokers
    base_ranks = [r for r in ranks if r != 'JOKER']
    if len(base_ranks) == 0:
        # all jokers -> treat as a valid set of jokers
        set_ok = True
        base_rank = 'JOKER'
    else:
        set_ok = len(set(base_ranks)) == 1
        base_rank = base_ranks[0] if base_ranks else None
    if set_ok and len(cards) >= 1:
        return {
            'type': 'set',
            'count': len(cards),
            # rank idx: use base_rank if available, else joker highest
            'rank_idx': (_rank_index_from_rank(base_rank) if base_rank else 999),
            'suits': suits,
            'all_spades': all_spades,
            'contains_8': contains_8,
            'contains_5': contains_5,
            'contains_7': contains_7,
            'contains_10': contains_10,
            'contains_J': contains_J,
            'contains_Q': contains_Q,
            'contains_K': contains_K,
            'contains_4': contains_4,
            'contains_A': contains_A,
            'contains_joker': contains_joker,
        }

    # straight
    if _is_straight(cards):
        top = _straight_top_idx(cards)
        # recompute suits/all_spades considering jokers: if non-joker cards exist, use their suit
        nonjoker = [c for c in cards if c != 'JOKER']
        suits = [c[-1] for c in nonjoker] if nonjoker else suits
        all_spades = all(s == '♠' for s in suits) if suits else False
        return {
            'type': 'straight',
            'count': len(cards),
            'top_idx': top,
            'suits': suits,
            'all_spades': all_spades,
            'contains_8': contains_8,
            'contains_5': contains_5,
            'contains_7': contains_7,
            'contains_9': contains_9,
            'contains_10': contains_10,
            'contains_J': contains_J,
            'contains_Q': contains_Q,
            'contains_K': contains_K,
            'contains_4': contains_4,
            'contains_A': contains_A,
        }

    return {'type': 'invalid', 'contains_8': contains_8, 'contains_5': contains_5, 'contains_7': contains_7, 'contains_9': contains_9, 'contains_10': contains_10, 'contains_J': contains_J, 'contains_K': contains_K, 'contains_Q': contains_Q, 'contains_joker': contains_joker}


def play_card(room_id: str, player_id: str, cards, target_rank: str = None) -> Dict[str, Any]:
    """
    cards: either a single card string or a list of card strings
    Simple rules implemented:
      - can play n cards if they all have the same rank
      - if center is empty: any valid set allowed
      - if center has m cards: you must play exactly m cards and higher rank
    """
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    if not room['started']:
        raise RuntimeError('game not started')
    # check turn
    if room['players'][room['current_turn']]['id'] != player_id:
        raise RuntimeError('not your turn')
    hand = room['hands'].get(player_id, [])
    if isinstance(cards, str):
        play_list = [cards]
    else:
        play_list = list(cards)
    # all cards must be in hand
    for c in play_list:
        if c not in hand:
            raise RuntimeError('card not in hand')
    # determine play meta (set or straight)
    meta = _play_meta(play_list)
    if meta['type'] == 'invalid':
        raise RuntimeError('invalid combination of cards')
    # center rules
    center = room.get('center') or []
    if center:
        center_meta = _play_meta(center)
        # types must match (set vs straight)
        if center_meta['type'] != meta['type']:
            raise RuntimeError('must play same type as center')
        if meta['type'] == 'set':
            # must play same number of cards
            if meta['count'] != center_meta['count']:
                raise RuntimeError('must play same number of cards as center')
            # special: if played contains 8 -> clears center
            if meta.get('contains_8'):
                # playing an 8 clears the center (effect applied after play)
                pass
            else:
                # spade-cut: if played all spades and center is not all spades, it's allowed
                if meta.get('all_spades') and not center_meta.get('all_spades'):
                    pass
                else:
                    # compare rank with possible revolution inversion
                    revolution = room.get('revolution', False)
                    if not _rank_greater(meta['rank_idx'], center_meta['rank_idx'], revolution=revolution):
                        raise RuntimeError('played rank is not higher than center')
        elif meta['type'] == 'straight':
            # must play same length
            if meta['count'] != center_meta['count']:
                raise RuntimeError('must play same number of cards as center (straight length)')
            # special: if played contains 8 -> clears center
            if meta.get('contains_8'):
                pass
            else:
                # spade-cut logic for straights: if all spades and center not all spades, allowed
                if meta.get('all_spades') and not center_meta.get('all_spades'):
                    pass
                else:
                    # compare top index with possible revolution inversion
                    revolution = room.get('revolution', False)
                    if not _rank_greater(meta['top_idx'], center_meta['top_idx'], revolution=revolution):
                        raise RuntimeError('played straight is not higher than center')
    # perform play
    for c in play_list:
        hand.remove(c)
    # reset this player's pass streak on a successful play
    room.setdefault('player_pass_streaks', {})[player_id] = 0
    # record plays to db
    try:
        if db:
            for c in play_list:
                db.add_play(room_id, player_id, c, meta=None)
    except Exception:
        pass

    # handle 8: playing an 8 clears the center and forces turn end
    if meta.get('contains_8'):
        room['center'] = []
        # when 8 is played, last_player is cleared (no lead) and passes reset
        room['last_player'] = None
        room['consecutive_passes'] = 0
        # clearing center should also clear revolution state
        if room.get('revolution'):
            room['revolution'] = False
            try:
                emit_event(room_id, 'revolution', {'active': False})
            except Exception:
                pass
        # if 9 also present (rare), shuffle handled below
    else:
        room['center'] = play_list
        # record last player and reset pass counter
        room['last_player'] = player_id
        room['consecutive_passes'] = 0
        # if this play contains J (11), toggle revolution
        if meta.get('contains_J'):
            room['revolution'] = not room.get('revolution', False)
            try:
                emit_event(room_id, 'revolution', {'active': room['revolution']})
            except Exception:
                pass
        # if this play contains K (13), toggle play direction
        if meta.get('contains_K'):
            cur = room.get('direction', 'clockwise')
            newd = 'counterclockwise' if cur == 'clockwise' else 'clockwise'
            room['direction'] = newd
            try:
                emit_event(room_id, 'direction', {'direction': newd})
            except Exception:
                pass
    # if play contains 10: allow optional discard of one card by the player
    if meta.get('contains_10'):
        # mark pending discard for this player; client may call discard_card to remove one card
        room['pending_discard'] = {'player_id': player_id, 'allowed': True}
        # do NOT advance turn until discard is handled (or player passes)
    else:
        room.pop('pending_discard', None)
    # if play contains 9: shuffle all hands and redistribute preserving counts
    if meta.get('contains_9'):
        _shuffle_hands(room)
    # Q special: mass discard (user mapped 12 -> 'Q')
    if meta.get('contains_Q') and target_rank:
        # note: in our rank set Q is 'Q', but user asked for 12->we mapped to 'Q'.
        # For safety, allow target_rank like '3','A','K' etc.
        discarded = []
        for p in room['players']:
            pid = p['id']
            hand = list(room['hands'].get(pid, []))
            to_remove = [c for c in hand if (c != 'JOKER' and c[:-1] == target_rank) or (c == 'JOKER' and target_rank == 'JOKER')]
            for c in to_remove:
                try:
                    room['hands'][pid].remove(c)
                except ValueError:
                    pass
            if to_remove:
                discarded.extend([{'player_id': pid, 'cards': to_remove}])
        try:
            emit_event(room_id, 'mass_discard', {'target_rank': target_rank, 'discarded': discarded})
        except Exception:
            pass
    # if player finished (no more cards), assign rank
    if len(room['hands'].get(player_id, [])) == 0:
        rank = room.get('next_rank', 1)
        room.setdefault('finished', {})[player_id] = rank
        room['next_rank'] = rank + 1
        try:
            if db:
                db.set_player_finished(room_id, player_id, rank)
        except Exception:
            pass
        # emit event to clients
        try:
            emit_event(room_id, 'player_finished', {'player_id': player_id, 'rank': rank})
        except Exception:
            pass
    # Check immediate double-4 or double-A special: if player played exactly 2 cards and both are rank 4 or both A (jokers allowed), apply instant grade rotation
    try:
        # determine base ranks excluding jokers
        ranks_played = [ (c[:-1] if c!='JOKER' else 'JOKER') for c in play_list ]
        nonjoker_ranks = [r for r in ranks_played if r != 'JOKER']
        if len(play_list) == 2 and len(nonjoker_ranks) <= 2:
            # check if they count as two 4s or two As (jokers can fill)
            def two_of(rank_symbol):
                # count nonjoker that equal rank_symbol plus jokers
                return (sum(1 for r in nonjoker_ranks if r == rank_symbol) + sum(1 for r in ranks_played if r == 'JOKER')) >= 2
            if two_of('4'):
                # immediate grade rotation triggered by double-4
                _apply_instant_grade_rotation(room_id, player_id, rank_type='4')
            elif two_of('A'):
                _apply_instant_grade_rotation(room_id, player_id, rank_type='A')
    except Exception:
        pass
    # handle special interactions: 4 (swap) or A (take)
    # when a 4 is played, allow the player to optionally swap one card with any other player
    if meta.get('contains_4'):
        # set pending swap: store actor and allow selecting target player and card
        room['pending_swap'] = {'player_id': player_id, 'allowed': True}
    # when an A is played, allow the player to optionally take one card from any player
    if meta.get('contains_A'):
        room['pending_take'] = {'player_id': player_id, 'allowed': True}
    # advance turn to next active player
    # advance turn to next active player unless this play was an 8 (8 makes the player lead)
    if not meta.get('contains_8'):
        _advance_to_next_active(room)
        # reset turn timestamp
        room['turn_started_at'] = datetime.utcnow().isoformat() + 'Z'
        # if played contains a 5, skip the next active player
        try:
            if meta.get('contains_5'):
                _advance_to_next_active(room)
        except Exception:
            pass
    # process bots if next are bots
    # append a message and emit event describing this play for clients (so chat shows what was played)
    try:
        if play_list:
            msg_txt = ','.join(play_list)
            ts = datetime.utcnow().isoformat() + 'Z'
            room.setdefault('messages', []).append({'player_id': player_id, 'name': next((p.get('display_name') or p.get('name') for p in room['players'] if p['id']==player_id), player_id), 'text': f'出した: {msg_txt}', 'ts': ts})
            emit_event(room_id, 'card_played', {'player_id': player_id, 'cards': play_list, 'ts': ts})
    except Exception:
        pass
    process_bots(room)
    # check if game is finished and handle end-game
    _end_game_if_finished(room_id)
    return room


def discard_card(room_id: str, player_id: str, card: str) -> Dict[str, Any]:
    """
    Player discards one card when allowed (e.g., after playing a 10). Discard is optional.
    """
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    pd = room.get('pending_discard')
    if not pd or pd.get('player_id') != player_id or not pd.get('allowed'):
        raise RuntimeError('no discard allowed')
    hand = room['hands'].get(player_id, [])
    if card not in hand:
        raise RuntimeError('card not in hand')
    # remove card and record as a discarded card (message + event)
    try:
        room['hands'][player_id].remove(card)
    except ValueError:
        raise RuntimeError('card not in hand')
    try:
        emit_event(room_id, 'card_discarded', {'player_id': player_id, 'card': card})
    except Exception:
        pass
    # clear pending and advance turn normally
    room.pop('pending_discard', None)
    # reset this player's pass streak since they took an action
    room.setdefault('player_pass_streaks', {})[player_id] = 0
    _advance_to_next_active(room)
    # process bots if next are bots
    process_bots(room)
    # persist discard as message if db available
    try:
        if db:
            db.add_message(room_id, player_id, next((p['name'] for p in room['players'] if p['id']==player_id), None), f'discarded {card}')
    except Exception:
        pass
    # check end of round
    _end_game_if_finished(room_id)
    return room


def pass_turn(room_id: str, player_id: str) -> Dict[str, Any]:
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    if not room['started']:
        raise RuntimeError('game not started')
    # check turn
    if room['players'][room['current_turn']]['id'] != player_id:
        raise RuntimeError('not your turn')
    # increment consecutive passes only for active players
    room['consecutive_passes'] = room.get('consecutive_passes', 0) + 1
    # increment per-player pass streak
    room.setdefault('player_pass_streaks', {})[player_id] = room.setdefault('player_pass_streaks', {}).get(player_id, 0) + 1
    # count active players (players who still have cards)
    active_players = [p for p in room['players'] if len(room['hands'].get(p['id'], [])) > 0]
    n_active = max(1, len(active_players))
    # if everyone except the last player has passed -> reset center
    # If no one has played yet (last_player is None) and all pass, just advance turns
    if room.get('last_player'):
        # number of others among active players = n_active - 1
        if room['consecutive_passes'] >= max(0, (n_active - 1)):
            # clear center and set current turn to the last player (they lead) if they still have cards
            room['center'] = []
            idx = next((i for i,p in enumerate(room['players']) if p['id'] == room['last_player']), None)
            if idx is not None and len(room['hands'].get(room['last_player'], [])) > 0:
                room['current_turn'] = idx
            else:
                # find next active
                _advance_to_next_active(room)
            room['consecutive_passes'] = 0
            # reset all players' pass streaks when center is cleared (new lead)
            for pid in list(room.get('player_pass_streaks', {}).keys()):
                room['player_pass_streaks'][pid] = 0
            return room
    # otherwise just advance turn
    # advance to next active player
    _advance_to_next_active(room)
    # update turn timestamp
    room['turn_started_at'] = datetime.utcnow().isoformat() + 'Z'
    # process bots if next are bots
    process_bots(room)
    # check end of round (everyone finished)
    if all(len(room['hands'].get(p['id'], [])) == 0 for p in room['players']):
        # round over - persist any remaining ranks
        for p in room['players']:
            pid = p['id']
            if pid not in room.get('finished', {}) and len(room['hands'].get(pid, [])) == 0:
                rank = room.get('next_rank', 1)
                room.setdefault('finished', {})[pid] = rank
                room['next_rank'] = rank + 1
                try:
                    if db:
                        db.set_player_finished(room_id, pid, rank)
                except Exception:
                    pass
        # after assigning remaining ranks, check and finalize game
        _end_game_if_finished(room_id)
    return room


def add_message(room_id: str, player_id: str, text: str) -> Dict[str, Any]:
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    # find player name
    pname = None
    for p in room['players']:
        if p['id'] == player_id:
            pname = p['name']
            break
    if pname is None:
        pname = 'Unknown'
    import datetime
    ts = datetime.datetime.utcnow().isoformat() + 'Z'
    msg = {'player_id': player_id, 'name': pname, 'text': text, 'ts': ts}
    room.setdefault('messages', []).append(msg)
    # keep messages capped
    if len(room['messages']) > 200:
        room['messages'] = room['messages'][-200:]
    try:
        if db:
            db.add_message(room_id, player_id, pname, text)
    except Exception:
        pass
    # after persisting message, trigger lightweight QA-based bot auto-reply
    try:
        _trigger_bot_auto_reply(room_id, player_id, text)
    except Exception:
        pass
    return msg


def _trigger_bot_auto_reply(room_id: str, sender_id: str, text: str):
    """If QA_PAIRS contains a match for the incoming text, choose a bot to reply.
    Matching is simple substring (case-insensitive). Replies are rate-limited per-bot and
    influenced by bot difficulty.
    """
    if not QA_PAIRS:
        return
    room = ROOMS.get(room_id)
    if not room:
        return
    t = (text or '').lower()
    answers = []
    for qa in QA_PAIRS:
        q = qa.get('q') or ''
        if not q:
            continue
        if q.lower() in t:
            a = qa.get('a')
            if a:
                answers.append(str(a))
    if not answers:
        return
    # choose one answer
    answer = random.choice(answers)
    # pick candidate bots (exclude sender)
    candidates = [p for p in room.get('players', []) if p.get('is_bot') and p.get('id') != sender_id]
    if not candidates:
        return
    # weight selection by difficulty and ensure rate-limit per bot
    weight_map = {'弱い': 0.2, 'ふつう': 0.6, '強い': 0.9}
    now = time.time()
    room.setdefault('bot_last_reply', {})
    # try a few attempts to find a bot that will reply
    attempts = 0
    while attempts < 6 and candidates:
        attempts += 1
        bot = random.choice(candidates)
        diff = bot.get('difficulty', 'ふつう')
        chance = weight_map.get(diff, 0.6)
        last = room['bot_last_reply'].get(bot['id'], 0)
        # require at least 3 seconds between bot replies
        if now - last < 3:
            # skip this bot for now
            candidates = [c for c in candidates if c['id'] != bot['id']]
            continue
        if random.random() <= chance:
            # send reply
            payload = {'player_id': bot['id'], 'text': answer, 'ts': datetime.utcnow().isoformat() + 'Z'}
            try:
                emit_event(room_id, 'bot_chat', payload)
                room['bot_last_reply'][bot['id']] = now
            except Exception:
                pass
            return
        else:
            candidates = [c for c in candidates if c['id'] != bot['id']]
    return


def process_bots(room: Dict[str, Any]):
    # while current player is bot and has cards, attempt minimal valid play
    n = len(room['players'])
    safety = 0
    while True:
        if safety > 500:
            break
        safety += 1
        cur = room['players'][room['current_turn']]
        if not cur.get('is_bot'):
            break
        pid = cur['id']
        hand = room['hands'].get(pid, [])
        if not hand:
            # bot finished, advance to next active
            _advance_to_next_active(room)
            continue

        played = None
        center = room.get('center') or []
        center_meta = _play_meta(center) if center else {'type': 'empty'}

        # determine bot preferences
        bot_info = cur or {}
        difficulty = bot_info.get('difficulty', 'ふつう')
        tone = bot_info.get('tone', 'いじわる')
        # map difficulty to joker usage threshold and aggressiveness
        if difficulty == '弱い':
            joker_allowed_streak = 4
            aggressive = False
        elif difficulty == '強い':
            joker_allowed_streak = 1
            aggressive = True
        else:
            joker_allowed_streak = 3
            aggressive = False

        def remove_from_hand(p_id, cards):
            for c in cards:
                try:
                    room['hands'][p_id].remove(c)
                except ValueError:
                    pass

        # attempt to find minimal valid play
        if center:
            if center_meta['type'] == 'set':
                cnt = center_meta['count']
                # group by rank
                rank_map = {}
                for c in hand:
                    rank_map.setdefault(c[:-1], []).append(c)
                # find candidate ranks sorted by rank value
                candidates = []
                for r, cards in rank_map.items():
                    if len(cards) >= cnt:
                        candidates.append(( _rank_value(cards[0]), sorted(cards, key=lambda x: _rank_value(x)) ))
                candidates.sort()
                for _, cards in candidates:
                    attempt = cards[:cnt]
                    meta = _play_meta(attempt)
                    # check 8-cut or spade-cut or rank higher
                    if meta.get('contains_8'):
                        played = attempt
                        break
                    if meta.get('all_spades') and not center_meta.get('all_spades'):
                        played = attempt
                        break
                    revolution = room.get('revolution', False)
                    if _rank_greater(meta['rank_idx'], center_meta.get('rank_idx', -1), revolution=revolution):
                        played = attempt
                        break
            elif center_meta['type'] == 'straight':
                cnt = center_meta['count']
                by_suit = {}
                jokers = [c for c in hand if c == 'JOKER']
                for c in hand:
                    if c == 'JOKER':
                        continue
                    by_suit.setdefault(c[-1], []).append(c)
                # look for straights of same length, include jokers as wildcards and prefer sequences that include jokers
                candidates = []
                for s, cards in by_suit.items():
                    # include available jokers so they can be used as wildcards for this suit
                    cards_with_jokers = list(cards) + list(jokers)
                    cards_sorted = sorted(cards_with_jokers, key=lambda x: _rank_value(x))
                    for i in range(len(cards_sorted) - cnt + 1):
                        seq = cards_sorted[i:i+cnt]
                        if _is_straight(seq):
                            meta = _play_meta(seq)
                            contains_joker = any(c == 'JOKER' for c in seq)
                            # Skip joker-containing sequences unless this bot's pass streak meets threshold
                            streak = room.get('player_pass_streaks', {}).get(pid, 0)
                            if contains_joker and streak < joker_allowed_streak:
                                continue
                            # sort key: prefer sequences that do NOT contain jokers (0), then smaller top_idx
                            # if aggressive, prefer larger top_idx (play stronger straights)
                            sort_top = meta.get('top_idx', -1)
                            sort_key = (0 if not contains_joker else 1, (-sort_top if aggressive else sort_top))
                            candidates.append((sort_key, seq, meta))
                # sort candidates by computed sort_key
                candidates.sort(key=lambda x: x[0])
                for _, seq, meta in candidates:
                    if meta.get('contains_8'):
                        played = seq
                        break
                    if meta.get('all_spades') and not center_meta.get('all_spades'):
                        played = seq
                        break
                    revolution = room.get('revolution', False)
                    if _rank_greater(meta.get('top_idx', -1), center_meta.get('top_idx', -1), revolution=revolution):
                        played = seq
                        break
        else:
            # lead: try minimal straight length 3 then smallest single
            hand_sorted = sorted(hand, key=lambda x: _rank_value(x))
            # try to find any straight length >=3, prefer smallest top
            found = False
            by_suit = {}
            jokers = [c for c in hand_sorted if c == 'JOKER']
            for c in hand_sorted:
                if c == 'JOKER':
                    continue
                by_suit.setdefault(c[-1], []).append(c)
            # prefer straights that can include jokers
            candidates = []
            for s, cards in by_suit.items():
                cards_with_jokers = list(cards) + list(jokers)
                cards_sorted = sorted(cards_with_jokers, key=lambda x: _rank_value(x))
                for length in range(3, len(cards_sorted)+1):
                    for i in range(len(cards_sorted)-length+1):
                        seq = cards_sorted[i:i+length]
                        if _is_straight(seq):
                            meta = _play_meta(seq)
                            contains_joker = any(c == 'JOKER' for c in seq)
                            streak = room.get('player_pass_streaks', {}).get(pid, 0)
                            # Skip joker-containing sequences unless this bot's pass streak meets threshold
                            if contains_joker and streak < joker_allowed_streak:
                                continue
                            top = meta.get('top_idx', -1)
                            key = (0 if not contains_joker else 1, -top if aggressive else top)
                            candidates.append((key, seq, meta))
            if candidates:
                candidates.sort(key=lambda x: x[0])
                played = candidates[0][1]
            if not played:
                # play weakest single
                if aggressive:
                    # play strongest single
                    played = [hand_sorted[-1]]
                else:
                    played = [hand_sorted[0]]

        if not played:
            # cannot play -> pass
            # emit a short bot chat on pass (tone-dependent)
            try:
                msg = None
                if tone == 'いじわる':
                    msg = 'またパスかよ、残念〜'
                elif tone == '真面目くん':
                    msg = '仕方ありません、パスします。'
                else:
                    msg = 'うーん…今回はパスしようかな？'
                # occasionally emit for variety; stronger bots more chatty
                if random.random() < (0.6 if aggressive else 0.25):
                    payload = {'player_id': pid, 'text': msg, 'ts': datetime.utcnow().isoformat() + 'Z'}
                    # append to room messages for history
                    try:
                        room.setdefault('messages', []).append({'player_id': pid, 'name': cur.get('display_name') or cur.get('name'), 'text': msg, 'ts': payload['ts']})
                    except Exception:
                        pass
                    emit_event(room['id'], 'bot_chat', payload)
            except Exception:
                pass
            try:
                pass_turn(room['id'], pid)
            except Exception:
                # if pass fails, advance to next active to avoid infinite loop
                _advance_to_next_active(room)
            continue

        # perform play (apply effects similarly to play_card)
        # remove from hand
        remove_from_hand(pid, played)
        # emit a small bot chat on play depending on tone
        try:
            pmsg = None
            if tone == 'いじわる':
                pmsg = 'こんなもんでどう？'
            elif tone == '真面目くん':
                pmsg = '出しました。'
            else:
                pmsg = 'やったー、出せたよ♪'
            if random.random() < (0.9 if aggressive else 0.4):
                payload = {'player_id': pid, 'text': pmsg, 'ts': datetime.utcnow().isoformat() + 'Z'}
                try:
                    room.setdefault('messages', []).append({'player_id': pid, 'name': cur.get('display_name') or cur.get('name'), 'text': pmsg, 'ts': payload['ts']})
                except Exception:
                    pass
                emit_event(room['id'], 'bot_chat', payload)
        except Exception:
            pass
        # reset this bot's pass streak because it took an action
        room.setdefault('player_pass_streaks', {})[pid] = 0
        # handle 8-cut: clears center
        pmeta = _play_meta(played)
        if pmeta.get('contains_8'):
            room['center'] = []
            room['last_player'] = None
            room['consecutive_passes'] = 0
        else:
            room['center'] = played
            room['last_player'] = pid
            room['consecutive_passes'] = 0
        # if played contains 9, shuffle hands
        if pmeta.get('contains_9'):
            _shuffle_hands(room)
        # record plays to db
        try:
            if db:
                for c in played:
                    db.add_play(room['id'], pid, c, meta=None)
        except Exception:
            pass
        # advance to next active player
        _advance_to_next_active(room)
        # if bot played a 5, skip next active
        try:
            if pmeta.get('contains_5'):
                _advance_to_next_active(room)
        except Exception:
            pass
        # loop continues to handle next bot
    return room


def get_room_state(room_id: str, player_id: str = None) -> Dict[str, Any]:
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    # record last seen for polling player_id
    try:
        if player_id:
            room.setdefault('last_seen', {})[player_id] = datetime.utcnow().isoformat() + 'Z'
    except Exception:
        pass
    # Note: auto-takeover and auto-pass are handled by a background monitor thread
    # to ensure accurate timing and avoid relying on client polling. get_room_state
    # only records last_seen here and returns the public state.
    # return shallow copy but hide other players' hands
    public_players = [
        {
            'id': p['id'],
            'name': p['name'],
            'display_name': p.get('display_name', p.get('name')),
            'tone': p.get('tone'),
            'difficulty': p.get('difficulty'),
            'is_bot': p['is_bot'],
            'hand_count': len(room['hands'].get(p['id'], [])) if room.get('started') else None,
        }
        for p in room['players']
    ]
    your_hand = None
    if player_id and room.get('hands'):
        your_hand = list(room['hands'].get(player_id, []))
    # expose pending_give only for requesting player to avoid leaking choices
    pending_give = None
    if player_id:
        pg = room.get('pending_give', {})
        cfg = pg.get(player_id)
        if cfg:
            # resolve target player's name for display
            to_pid = cfg.get('to')
            to_name = next((p['name'] for p in room['players'] if p['id'] == to_pid), None)
            # add recipient info
            to_player = next((p for p in room['players'] if p['id'] == to_pid), None)
            to_hand_count = len(room['hands'].get(to_pid, [])) if to_pid else None
            to_is_bot = to_player.get('is_bot') if to_player else False
            # attempt to get rank/score from room state or db
            to_rank = None
            if room.get('finished') and to_pid in room.get('finished', {}):
                try:
                    to_rank = int(room['finished'][to_pid])
                except Exception:
                    to_rank = None
            to_score = None
            if db and to_pid:
                try:
                    conn = db.get_conn()
                    cur = conn.execute('SELECT score, finished_rank FROM players WHERE id = ? AND game_id = ?', (to_pid, room['id']))
                    row = cur.fetchone()
                    if row:
                        try:
                            to_score = int(row['score']) if row['score'] is not None else None
                        except Exception:
                            to_score = None
                        if to_rank is None:
                            try:
                                fr = row['finished_rank']
                                to_rank = int(fr) if fr is not None else None
                            except Exception:
                                pass
                except Exception:
                    pass
            pending_give = {'to': to_pid, 'to_name': to_name, 'count': cfg.get('count'), 'allowed': cfg.get('allowed'), 'to_hand_count': to_hand_count, 'to_is_bot': to_is_bot, 'to_rank': to_rank, 'to_score': to_score}
    return {
        'id': room['id'],
        'players': public_players,
        'started': room['started'],
        'current_turn': room['current_turn'],
        'center': room['center'],
        'your_hand': your_hand,
        'messages': list(room.get('messages', [])),
        'turn_started_at': room.get('turn_started_at'),
        'revolution': room.get('revolution', False),
        'pending_discard': room.get('pending_discard'),
        'pending_give': pending_give,
        'last_player': room.get('last_player'),
        'direction': room.get('direction', 'clockwise'),
    }


def _advance_to_next_active(room: Dict[str, Any]):
    """Advance current_turn to the next player index that still has cards. If none, leave as is."""
    n = len(room['players'])
    if n == 0:
        return
    dir_setting = room.get('direction', 'clockwise')
    for _ in range(n):
        if dir_setting == 'clockwise':
            room['current_turn'] = (room['current_turn'] + 1) % n
        else:
            room['current_turn'] = (room['current_turn'] - 1) % n
        pid = room['players'][room['current_turn']]['id']
        if len(room['hands'].get(pid, [])) > 0:
            # record when this turn started
            room['turn_started_at'] = datetime.utcnow().isoformat() + 'Z'
            return


class RoomMonitor(threading.Thread):
    """Background thread that enforces accurate timeouts for turns and takeover."""
    def __init__(self, poll_interval: float = 0.5, takeover_threshold: float = 30.0, pass_threshold: float = 60.0):
        super().__init__(daemon=True)
        self.interval = poll_interval
        self.takeover_threshold = takeover_threshold
        self.pass_threshold = pass_threshold
        self._stop = threading.Event()

    def run(self):
        while not self._stop.is_set():
            try:
                now = datetime.utcnow()
                for room_id, room in list(ROOMS.items()):
                    try:
                        if not room.get('started'):
                            continue
                        cur_idx = room.get('current_turn')
                        if cur_idx is None:
                            continue
                        if not (0 <= cur_idx < len(room.get('players', []))):
                            continue
                        cur_player = room['players'][cur_idx]
                        cur_pid = cur_player.get('id')
                        # check last_seen for takeover (only for human players)
                        if cur_player and not cur_player.get('is_bot'):
                            last_iso = room.get('last_seen', {}).get(cur_pid)
                            if last_iso:
                                        last_dt = datetime.fromisoformat(last_iso.replace('Z', ''))
                                        if (now - last_dt).total_seconds() > self.takeover_threshold:
                                        # perform takeover
                                            cur_player['is_bot'] = True
                                            cur_player['taken_over'] = True
                                            cur_player['takeover_at'] = datetime.utcnow().isoformat() + 'Z'
                                        try:
                                            emit_event(room_id, 'player_taken_over', {'player_id': cur_pid, 'by_bot': True})
                                        except Exception:
                                            pass
                                        # if contact info exists, send notification
                                        try:
                                            contact = cur_player.get('contact_email') or cur_player.get('contact_phone')
                                            if contact:
                                                _send_contact_notification(cur_player, room_id, reason='takeover')
                                        except Exception:
                                            pass
                                        # let process_bots handle immediate action in next iteration
                                        except Exception:
                                            pass
                        else:
                            # if current player is bot but was previously taken_over, and we detect a recent last_seen for that player
                            if cur_player and cur_player.get('taken_over'):
                                last_iso = room.get('last_seen', {}).get(cur_player.get('id'))
                                if last_iso:
                                        last_dt = datetime.fromisoformat(last_iso.replace('Z', ''))
                                        # if recently polled within half the takeover threshold, auto-release
                                        if (now - last_dt).total_seconds() <= (self.takeover_threshold / 2.0):
                                            # auto-release: mark back to human
                                            cur_player['is_bot'] = False
                                            cur_player.pop('taken_over', None)
                                            cur_player.pop('takeover_at', None)
                                            try:
                                                emit_event(room_id, 'player_released', {'player_id': cur_player.get('id')})
                                            except Exception:
                                                pass
                                            # notify player that control returned (if contact available)
                                            try:
                                                contact = cur_player.get('contact_email') or cur_player.get('contact_phone')
                                                if contact:
                                                    _send_contact_notification(cur_player, room_id, reason='released')
                                            except Exception:
                                                pass
                        # check turn_started_at for forced pass (only for human players)
                        if cur_player and not cur_player.get('is_bot'):
                            ts = room.get('turn_started_at')
                            if ts:
                                try:
                                    started = datetime.fromisoformat(ts.replace('Z', ''))
                                    if (now - started).total_seconds() >= self.pass_threshold:
                                        try:
                                            pass_turn(room_id, cur_pid)
                                        except Exception:
                                            # swallow — ensure monitor loop continues
                                            pass
                                except Exception:
                                    pass
                        # after any action, if next are bots, let process_bots run (non-blocking-ish)
                        # Note: process_bots may loop; call it but protect with try/except
                        try:
                            # only call process_bots when current player is a bot
                            cur_idx = room.get('current_turn')
                            if cur_idx is not None and 0 <= cur_idx < len(room.get('players', [])):
                                if room['players'][cur_idx].get('is_bot'):
                                    process_bots(room)
                        except Exception:
                            pass
                    except Exception:
                        # ignore room-level errors to avoid killing monitor
                        pass
            except Exception:
                pass
            self._stop.wait(self.interval)

    def stop(self):
        self._stop.set()


# create and start a global monitor instance
_GLOBAL_MONITOR: RoomMonitor = None
def _ensure_monitor_started():
    global _GLOBAL_MONITOR
    if _GLOBAL_MONITOR is None:
        try:
            _GLOBAL_MONITOR = RoomMonitor()
            _GLOBAL_MONITOR.start()
        except Exception:
            _GLOBAL_MONITOR = None


# start on import
_ensure_monitor_started()


def _shuffle_hands(room: Dict[str, Any]):
    """Collect all cards from players' hands, shuffle, and redistribute preserving counts."""
    # collect counts
    counts = {p['id']: len(room['hands'].get(p['id'], [])) for p in room['players']}
    all_cards = []
    for pid in counts:
        all_cards.extend(room['hands'].get(pid, []))
    random.shuffle(all_cards)
    # redistribute
    new_hands = {}
    idx = 0
    for pid, cnt in counts.items():
        new_hands[pid] = all_cards[idx:idx+cnt]
        idx += cnt
    room['hands'] = new_hands
    try:
        emit_event(room['id'], 'hands_shuffled', {'counts': counts})
    except Exception:
        pass
    return room


def give_card(room_id: str, from_player_id: str, card: str, direction: str = None) -> Dict[str, Any]:
    """
    Transfer a single card from from_player to their neighbor optionally.
    Allowed only if the from_player was the last to play and that play contained a 7.
    direction: optional 'left' or 'right' to override room direction.
    """
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    # validate player and card
    if card not in room['hands'].get(from_player_id, []):
        raise RuntimeError('card not in hand')
    # ensure last play was by this player and contained a 7
    center = room.get('center') or []
    center_meta = _play_meta(center) if center else {'type': 'empty'}
    if room.get('last_player') != from_player_id or not center_meta.get('contains_7'):
        raise RuntimeError('can only give after you played a 7')

    # determine recipient index
    n = len(room['players'])
    idx = next((i for i,p in enumerate(room['players']) if p['id'] == from_player_id), None)
    if idx is None:
        raise RuntimeError('player not in room')
    if direction:
        if direction == 'left':
            ridx = (idx + 1) % n
        elif direction == 'right':
            ridx = (idx - 1) % n
        else:
            raise RuntimeError('invalid direction')
    else:
        # use room direction (default clockwise)
        dir_setting = room.get('direction', 'clockwise')
        if dir_setting == 'clockwise':
            # right neighbor
            ridx = (idx - 1) % n
        else:
            # counterclockwise -> left neighbor
            ridx = (idx + 1) % n

    recipient = room['players'][ridx]
    # perform transfer
    try:
        room['hands'][from_player_id].remove(card)
    except ValueError:
        raise RuntimeError('card not in hand')
    room['hands'].setdefault(recipient['id'], []).append(card)
    # emit event
    try:
        emit_event(room_id, 'card_given', {'from': from_player_id, 'to': recipient['id'], 'card': card, 'direction': direction or room.get('direction', 'clockwise')})
    except Exception:
        pass
    # persist to db as message
    try:
        if db:
            db.add_message(room_id, from_player_id, next((p['name'] for p in room['players'] if p['id']==from_player_id), None), f'gave {card} to {recipient["id"]}')
    except Exception:
        pass
    return room


def swap_cards(room_id: str, player_id: str, target_player_id: str, give_card: str, take_card: str) -> Dict[str, Any]:
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    pd = room.get('pending_swap')
    if not pd or pd.get('player_id') != player_id or not pd.get('allowed'):
        raise RuntimeError('no swap allowed')
    # validate ownership
    if give_card not in room['hands'].get(player_id, []):
        raise RuntimeError('give_card not in hand')
    if take_card not in room['hands'].get(target_player_id, []):
        raise RuntimeError('take_card not in target hand')
    # perform swap
    room['hands'][player_id].remove(give_card)
    room['hands'][target_player_id].remove(take_card)
    room['hands'][player_id].append(take_card)
    room['hands'][target_player_id].append(give_card)
    # clear pending and emit event
    room.pop('pending_swap', None)
    try:
        emit_event(room_id, 'cards_swapped', {'from': player_id, 'to': target_player_id, 'gave': give_card, 'took': take_card})
    except Exception:
        pass
    return room


def take_card(room_id: str, player_id: str, target_player_id: str, take_card: str) -> Dict[str, Any]:
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    pd = room.get('pending_take')
    if not pd or pd.get('player_id') != player_id or not pd.get('allowed'):
        raise RuntimeError('no take allowed')
    if take_card not in room['hands'].get(target_player_id, []):
        raise RuntimeError('take_card not in target hand')
    # transfer
    room['hands'][target_player_id].remove(take_card)
    room['hands'].setdefault(player_id, []).append(take_card)
    room.pop('pending_take', None)
    try:
        emit_event(room_id, 'card_taken', {'by': player_id, 'from': target_player_id, 'card': take_card})
    except Exception:
        pass
    return room


def submit_give(room_id: str, player_id: str, cards: List[str]) -> Dict[str, Any]:
    """Player (富豪 or 大富豪) submits cards to give back to poorer players as configured in pending_give."""
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    pending = room.get('pending_give', {})
    cfg = pending.get(player_id)
    if not cfg or not cfg.get('allowed'):
        raise RuntimeError('no give pending for player')
    to_pid = cfg.get('to')
    count = cfg.get('count', 1)
    if not isinstance(cards, list) or len(cards) != count:
        raise RuntimeError(f'expected {count} card(s) to give')
    # validate ownership
    for c in cards:
        if c not in room['hands'].get(player_id, []):
            raise RuntimeError('card not in hand')
    # perform transfer
    for c in cards:
        room['hands'][player_id].remove(c)
    room['hands'].setdefault(to_pid, []).extend(cards)
    # clear pending for this player
    room['pending_give'].pop(player_id, None)
    try:
        emit_event(room_id, 'give_submitted', {'from': player_id, 'to': to_pid, 'cards': cards})
    except Exception:
        pass
    return room


def takeover_for_player(room_id: str, player_id: str) -> Dict[str, Any]:
    """Manually start a bot takeover for a given player_id in the room.
    This marks the player as taken_over and is_bot True so process_bots will act for them.
    Returns the updated player dict.
    """
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    p = next((x for x in room['players'] if x['id'] == player_id), None)
    if not p:
        raise KeyError('player not found')
    p['is_bot'] = True
    p['taken_over'] = True
    p['takeover_at'] = datetime.utcnow().isoformat() + 'Z'
    try:
        emit_event(room_id, 'player_taken_over', {'player_id': player_id, 'by_bot': True})
    except Exception:
        pass
    return p


def release_takeover(room_id: str, player_id: str) -> Dict[str, Any]:
    """Revoke a takeover previously applied (if player reconnects). This will mark the player back to human.
    Note: does not restore original hand ownership — this is a light-weight flag toggle.
    """
    room = ROOMS.get(room_id)
    if not room:
        raise KeyError('room not found')
    p = next((x for x in room['players'] if x['id'] == player_id), None)
    if not p:
        raise KeyError('player not found')
    p['is_bot'] = False
    p.pop('taken_over', None)
    p.pop('takeover_at', None)
    try:
        emit_event(room_id, 'player_released', {'player_id': player_id})
    except Exception:
        pass
    return p


def _apply_instant_grade_rotation(room_id: str, actor_player_id: str, rank_type: str = '4'):
    """When double-4 or double-A occurs, rotate ranks: 大富豪 -> 大貧民 (drop), 貧民->平民->富豪->... per user's description.
    We will implement a simple mapping: if someone is currently 大富豪 (rank==1), they become 大貧民 (max rank), others shift up one grade. For simplicity use finished mapping if available; otherwise apply no-op.
    """
    room = ROOMS.get(room_id)
    if not room:
        return
    finished = room.get('finished', {})
    if not finished:
        # No finished mapping yet; we still set a special event for clients to handle
        try:
            emit_event(room_id, 'instant_grade_rotation', {'by': actor_player_id, 'type': rank_type})
        except Exception:
            pass
        return
    # compute inverted mapping: find current 大富豪 (rank==1) and largest rank
    max_rank = max(finished.values()) if finished else 0
    # find player with rank 1
    daifugo = next((pid for pid, r in finished.items() if r == 1), None)
    if not daifugo:
        try:
            emit_event(room_id, 'instant_grade_rotation', {'by': actor_player_id, 'type': rank_type})
        except Exception:
            pass
        return
    # who becomes 大貧民 -> the previous daifugo
    # increment everyone's rank by -1 (improve) except daifugo which goes to max_rank
    new_finished = {}
    for pid, r in finished.items():
        if pid == daifugo:
            new_finished[pid] = max_rank
        else:
            # promote everyone else by -1 rank number (e.g., 2->1, 3->2)
            new_finished[pid] = max(1, r - 1)
    room['finished'] = new_finished
    try:
        if db:
            db.record_round_results(room_id, new_finished)
    except Exception:
        pass
    # attach titles
    titled = [{'player_id': pid, 'rank': r, 'title': title_for_rank(r)} for pid, r in new_finished.items()]
    try:
        emit_event(room_id, 'instant_grade_rotation', {'by': actor_player_id, 'new_finished': new_finished, 'titled': titled})
    except Exception:
        pass


def _end_game_if_finished(room_id: str):
    """
    Check if the game is finished (all players have finished or only one left with cards).
    If finished, persist results to DB and mark room as not started (ready for next round).
    """
    room = ROOMS.get(room_id)
    if not room:
        return
    # finished players mapping
    finished = room.get('finished', {})
    # check if any players still have cards
    players_with_cards = [p for p in room['players'] if len(room['hands'].get(p['id'], [])) > 0]
    # finalize only when nobody has cards left (all players finished)
    if len(players_with_cards) == 0 and len(finished) > 0:
        # ensure all players have a rank (assign remaining last ranks)
        next_rank = room.get('next_rank', 1)
        for p in room['players']:
            pid = p['id']
            if pid not in finished:
                finished[pid] = next_rank
                next_rank += 1
        room['finished'] = finished
        room['next_rank'] = next_rank
        # compute score or results list
        results = [{'player_id': pid, 'rank': rank, 'title': title_for_rank(rank)} for pid, rank in finished.items()]
        # call db to persist final game state
        try:
            if db:
                db.set_game_finished(room['id'], results)
        except Exception:
            pass
        # Mark room as finished; keep center/hands for clients to inspect final play
        room['started'] = False
        room['game_over'] = True
        # emit game_finished event
        try:
            emit_event(room_id, 'game_finished', {'results': results})
        except Exception:
            pass
        # leave center, deck and hands intact so callers/tests can inspect final play
        # reset turn and counters to safe defaults
        room['current_turn'] = 0
        room['last_player'] = None
        room['consecutive_passes'] = 0
        return room

